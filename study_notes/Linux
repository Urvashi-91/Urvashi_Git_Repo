Scenario 1: CPU overheats when upgrading, upgrade without overheating
Solution 1: Check reason for oveheat in the 'systemd' via 'journalctl' and search for 'critical temprature'.
            Have proper sensor modules loaded - 'sensors-detect'
            Any culprit app -- CPU over used -- DC room poorly cooled -- failing h/w -- look for upgrade bugs
            Use TLP to monitor heat/system under control -- cpufreq
            
Scenario 2: High site users, scale up your system that is getting popular
Solution 2: Database Sharding -- Sharding based on TweetID -- Use Consistent Hashing to redistribute data -- each 
            hash function return set of tweets and central server aggregate results and return to user. What if we can 
            combine sharding by TweetID and Tweet creation time? If we don’t store tweet creation time separately and use
            TweetID to reflect that, we can get benefits of both the approaches. This way it will be quite quick to find the latest Tweets. 
            For this, we must make each TweetID universally unique in our system and each TweetID should contain a timestamp too.
            We can use epoch time for this. Let’s say our TweetID will have two parts: the first part will be representing epoch seconds and 
            the second part will be an auto-incrementing sequence. So, to make a new TweetID, we can take the current epoch time and append an 
            auto-incrementing number to it. We can figure out the shard number from this TweetID and store it there.
            
Scenario 3: How to debug a remote server?
Solution 3: Using a debugger running on the host and connects to program on target to fetch information about the system -- GDB server
            GDB -- Execute this on host system to connect with target
            gdbserver -- run this on target server
            #gdbserver localhost:2000 my_program.py (target)
            #gd my_program.py (host)
            GDB is the GNU Project debugger, allows you to see what is going on `inside' another program while it executes
            
Scenario 4: How busy is the CPU?
Solution 4: #top (cpu load) #mpstat (cpu activity) #sar (cpu utilization) #iostat (average usage)

Scenario 5: What is loopback?
Solution 5: In linux every n/w connection can be added using nmcli -- every n/w connection there is a loopback -- loopbac is TCP/IP utility
            that allows interaction b/w Client and Server softwares -- troubleshooting using commands (ping, tracepath, traceroute)
            The loopback device is a special, virtual network interface that your computer uses to communicate with itself. 
            It is used mainly for diagnostics and troubleshooting, and to connect to servers running on the local machine.

Scenario 6: How to change priroty of a process?
Solution 6: renice or nice utiltity -- 
            Nice command will launch a process with an user defined scheduling priority. 
            Renice command will modify the scheduling priority of a running process. 
            Linux Kernel schedules the process and allocates CPU time accordingly for each of them.
                  
Scenario 7: How to view a url status without downloading its content?
Solution 7: You may use curl instead to check if the URLs you are parsing are there without downloading any file as such:

                        if curl --head --fail --silent "$url" >/dev/null; then
                            touch .images/"${url##*/}"
                        fi
                        Explanation:

                        --fail will make the exit status nonzero on a failed request.
                        --head will avoid downloading the file contents
                        --silent will avoid status or errors from being emitted by the check itself.
                        To solve the "looping" issue, you can do:

                        urls=( "${url%.jpg}"_{001..005}.jpg )
                        for url in "${urls[@]}"; do
                            if curl --head --silent --fail "$url" > /dev/null; then
                                touch .images/${url##*/}
                            fi
                        done
                        
                        urls=( "${url%.jpg}"_{001..005}.jpg )
                        for url in "${urls[@]}"; do
                            if wget -q --method=HEAD "$url"; then
                                touch .images/${url##*/}
                            fi
                        done
              What this does is that it invokes Wget with the --method=HEAD option. With the HEAD request, the server will simply report back whether the file exists or not, 
              without returning any data.
            
Scenario 8: What’s void *?
Solution 8: A pointer to void is a "generic" pointer type. A void * can be converted to any other pointer type without an explicit cast.void * is often used in places where you need to be able to work with different pointer types in the same code.
            
Scenario 9: What’s the system call for creating files?
Solution 9: The 0 file descriptor identifies the standard input, 1 identifies the standard output and 2 the standard output for errors. 
            The rest of the descriptors are used by the processes when opening an ordinary, pipe or special file, or directories. 
            There are five system calls that generate file descriptors: create, open, fcntl, dup and pipe.
            Open: read, write, lseek and close, Link, Unlink, stat, lstat, fstat
            Src: https://profile.iiita.ac.in/bibhas.ghoshal/lab_files/System%20calls%20for%20files%20and%20directories%20in%20Linux.html
            

Scenario 10: What happens when you hit curl in linux?
Solution 10: bash searches for executable "curl" in directories from PATH env var, once found it forks a process passing in the arg "www.google.com". 
            After that, a call to the kernel is made to handle requests to the network. The network stack is used (TCP/IP) to arbitrate for access to the resources, 
            the request gets broken down into muliple packets onto the network, first to DNS for address translation to IP, then out to the internet and back with muliple packets. 
            When arrived it gets checksumed and re-ordered and sent back to the application
            DETAILED: The shell splits a line of input into tokens.
             The shell performs wildcard expansion and parameter replacement on the tokens.
             If the first token, 'curl', is not an alias or shell function, then the shell will search the directories which are components of PATH for a matching file. 
             Each test in the sequence will be given to the kernel, which will resolve the directory path to a specific mounted filesystem, and then search the directory content in the filesystem.
            The shell will fork() creating a parent and child process.
            The kernel will handle the fork request by copying the process structure, stack, open files (including stdin, stdout, and stderr) 
                        and references to the heap memory to a new identical process, which will then be given a new process ID.
            The parent process will wait; the child process calls an exec() function.
            The kernel will determine if the path given to exec() is executable.
            For a dynamically linked ELF binary marked executable, the kernel will use ld.so to load the required shared objects into memory, 
                        resolve references to symbols in the shared objects into memory addresses, and begin execution of instructions in the ELF binary. 
                        The child shell process is replaced with the curl process.
            The curl process parses its command line arguments.
            The curl process will parse the argument it identifies as a URL in order to determine the protocol, host, port, and path.
            Curl will resolve the hostname to an address. I believe it will use getnameinfo(). The system resolver library will open /etc/nsswitch.conf to determine which modules to use for "hosts" resolution.
            The resolver library will dynamically load shared objects named in nsswitch.conf to continue dns resolution.
            The resolver library will parse /etc/resolv.conf in order to determine search domains, DNS servers, and other settings.
            The resolver library's "files" library will open /etc/hosts to check for the name.
            The resolver library's "dns" library will serialize the request for the host into requests for A and AAAA recordsThe .
            The resolver library will "open" a connection to the first DNS server and send the request.
            The kernel will create an IP packet containing its address and a newly allocated UDP port as the source, and the DNS servers's address and UDP port 53 as the destination.
            The kernel will check the routing table to see if the DNS server IP address is local, or if it requires routing through a gateway.
            The kernel will determine the MAC address of the next hop using either ARP for IPv4 or neighbor discovery for IPv6.
            The kernel will create an Ethernet frame containing the IP packet it created earlier, with its MAC address as the source and the MAC address of the next hop as the destination.
            The kernel sends the Ethernet frame.
(We have to REALLY simplify this for DNS or we'll go on forever.)
            If the DNS server doesn't have any answer cached, it'll send the request to the root name servers (A for www.example.com). The root nameservers will respond with the most specific information they have. If they don't know www.example.com or example.com, they may respond with the NS for "com". The DNS server then sends the request (A for www.example.com) to that nameserver. This process continues until it finds a nameserver that can answer the query. We will assume that the answer is small enough to fit in a UDP packet, and the process doesn't have to start over on TCP, but that can happen too.
            The client gets a reply, and now it knows the address for the host.
            curl will connect() to the IP address and TCP port. This follows a kernel process similar to the one we described earlier.
            The kernel of the client and server engage in a three-way handshake to establish a TCP connection. SYN, SYN/ACK, and ACK.
            We're going to skip TLS entirely, because wow that'd take a long time.
            curl serializes its request into the appropriate protocol That might be HTTP 1.1. The request might look like:
            GET /path HTTP/1.1
            Host: www.example.com
            The server parses the request, and decides how to handle it. Name-based virtual hosting may be a factor. The server may be a front-end for a web application, in which case the request is re-serialized and passed on through some other protocol over some other socket layer. If it resolves to a regular file, the server may be able to handle the request internally.
            The HTTP server builds a response that includes a description of the file it will send. It sends the description and then the file back over the client socket, and then closes the connection.
            curl reads the response headers in order to understand how it should handle the response.
            For an HTML file, curl will normally print to standard output. curl reads bytes from the network socket, and then writes those bytes to its standard output file.
            The kernel receives the bytes written to standard output and delivers them to the appropriate destination. This is probably to a TTY handled by a terminal emulator.
            You'll note that it starts to get vague at the end, because it's already a very long list and things are fairly complex. Depending on what your interests are, I may have left out the important stuff entirely. My conversation with my wife, for instance, was really directed at discussing TLS and how requests are handled by web frameworks. Both of those are excluded above.

Scenario 11: System calls, most importantly the popular ones like [src: https://linuxhint.com/list_of_linux_syscalls/]
            fork(): Creates child process [pid_t fork(void) --> Returns list of child processes]
            creat(): Create child process without copying page tables of parent process.  
            open(): Opens or creates a file, depending on the flags passed to the call. 
            read(): Reads from a specified file using a file descriptor. 
            write(): Writes to a specified file using a file descriptor.
            exec(): Execute a program.
            stat(): Returns information about a file in a structure named stat (lstat for symbolic link, fstat for file descriptor)
            sbrk(): change the location of the program break (brk())
            mmap(): Maps files or devices into memory.
            
Scenario 12: What does malloc() do and how to re-allocate or free memory? [src: https://man7.org/linux/man-pages/man3/malloc.3.html]
Solution 12: malloc():allocates size bytes and returns a pointer to the allocated memory.
             free(): frees the memory space pointed to by ptr, which must have been returned by a previous call to malloc()
             The Linux memory allocator works by mapping pages from physical memory to virtual memory. It can either map a contiguous area or sparse chunks from physical memory, 
             to a contiguous area in virtual memory. Using the buddy algorithm, physical memory can be arranged in contiguous sets of pages (let's call them buckets).
             
Scenario 13: File system internals, like the role of inode or dentry.
Solution 13: Superblock: file system metadata and defines the file system type, size, status, and information about other metadata structures (metadata of metadata). 
                        dumpe2fs /dev/foo | grep -i superblock
             Inode:represents metadata about a file.information about ownership (user, group), access mode (read, write, execute permissions), file type, and the data blocks with the file's content.
             Dentry: glue that holds inodes and files together by relating inode numbers to file names. Dentries also play a role in directory caching which, ideally, keeps the most frequently used files on-hand for faster access. 
                     File system traversal is another aspect of the dentry as it maintains a relationship between directories and their files.
Scenario 14: The lifecycle and the state of processes.
Solution 14: 
Scenario 15: You are given disks with empty spaces, yet cannot write anything on the disks? What could be the reason?
Scenario 16: Draw an architecture where a service is up most of the time
SCENARIO 17: WHAT IS THE PURPOSE OF WITH STATEMENT IN PYTHON
Scenario 18: How would you design a Build and Release system for IOT devices or sensors?
Scenarios 19: How would you handle data from IOT or sensors devices? --> Stream data processing

Scenario 20: You have a service Gerrit that is being restarted every 5 mins by systemd? troubleshoot (journalctl)
Solution 20: 1. Look for logs --> journalctl for logs (-u servicename, -t timestamp) / systemctl show logs (state of process) 2. Service setting could be set to restart

Scenario 21: You have a Jenkins process that is running but the Jenkins User Interface is not up. Troubleshoot why? (dump)
Solution 21: Jenkins UI port is not open to be accessed from outside | curl is not working firewall | 

Scenario 22: You have to clone Git file which is huge in size and in USA, and you have to clone it in India. But the clone is getting timed out? Troubleshoot
Solution 22: git logs

Scenraio 23: How would you monitor 1000 servers and generate reports based on the specified metrics?
Solution 23: Monitoring Grafana GUI - Prometheus agent deploy on new server, bootstrap expose metrics -- then configure dashboard - CPU,mem,n/w,ports

Scenario 24: You are growing your enviroment and you need to migrate a baremetal based application on kubesystem. The application is running on Ubuntu12 and using old Python version. How would you plan the migration?
Solution 24: POD= application has dependency based on container dockerfile-image will be same as app and code location (From, command to run and how will my application start) | Container layers(readable/writable) data through persistence storage (NAS/expose to kubernetes cluster)

Scenario 25: What is context switching:
Solution 25: Context Switching involves storing the context or state of a process so that it can be reloaded when required and execution can be resumed from the same point as earlier. 
            This is a feature of a multitasking operating system and allows a single CPU to be shared by multiple processes.
            Procedure: 1. Initially Process 1 is running. Process 1 is switched out and Process 2 is switched in because of an interrupt or a system call. 
                       2. Context switching involves saving the state of Process 1 into PCB1 and loading the state of process 2 from PCB2. 
                       3. After some time again a context switch occurs and Process 2 is switched out and Process 1 is switched in again. 
                       4. This involves saving the state of Process 2 into PCB2 and loading the state of process 1 from PCB1.
           
Scenario 26: Boot Process - Linux
Solution 26: 1. BIOS - Searches hard drives, USB, CD-ROMs, network cards, or any other hardware it can boot from.
             2. MBR: Master Boot Record, 512 bytes of HD this si where the boot code is.
             3. 
 Scenario 27: How to enrypt Passwords?
 Solution 27: 
 
 Scenario 28: Stateful set is for order of an application to start them in order
 Scenarios 29: Persistance app
Solution 29: PVPVC storage persistence Physical Volume (NFS storage) Physcial Volume Claim (Present to kubernetes volume for application)


Scenario 29: You are troubleshooting an app that is showing content not available. You can remotely access the application internet. Troubleshoot?
Solution 29: Traceroute application server - curl and see http response

Scenario 29.1: How traceroute works? How does it stop based on TTL? Where are the addresses given for the next hop?
Scenario 29.2: How curl works?
Scenario 29.2: What happends after tcp handshake/ at SSL/TLS level? How self signed certificate work?
Scenario 29.3: What does too many open files error mean? How does lsof work? Where is the limit mentioned? How do you see anything in /proc?
Scenario 20: Design a migration from On prem to Docker containers on Kubernetes cluster
Scenario : SSH not working so you login to console (ilo) mysql-admin:# prompt what does this mean? How do you troubleshoot if none of the commands working (FORK: resource not available)? inside proc how to get the info -- how to restart everything.
Scenario : Blackbox and whitebox monitoring? SLA,SLO,SLI
Scenario: Transfer huge number of files from one server to another?
Git error: conflict , troubleshoot
Git commit needs to be reverted, how?
Jenkins logs how to check those? how to automatically fix build and error without manual intervention?
Website not responding, troubleshoot...strace
multiprocessing vs mltithreading
how to multiprocessing usingchunks which is variant
how to parse a json file
array and dictionary
synchronous and asynchronous
how to migrate to aws what all steps to consider and security to make sure for a private servers?
how to set an interfac's MTU. (ifconfig ip-link)






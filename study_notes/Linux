Scenario 1: CPU overheats when upgrading, upgrade without overheating
Solution 1: Check reason for oveheat in the 'systemd' via 'journalctl' and search for 'critical temprature'.
            Have proper sensor modules loaded - 'sensors-detect'
            Any culprit app -- CPU over used -- DC room poorly cooled -- failing h/w -- look for upgrade bugs
            Use TLP to monitor heat/system under control -- cpufreq
            
Scenario 2: High site users, scale up your system that is getting popular
Solution 2: Database Sharding -- Sharding based on TweetID -- Use Consistent Hashing to redistribute data -- each 
            hash function return set of tweets and central server aggregate results and return to user. What if we can 
            combine sharding by TweetID and Tweet creation time? If we don’t store tweet creation time separately and use
            TweetID to reflect that, we can get benefits of both the approaches. This way it will be quite quick to find the latest Tweets. 
            For this, we must make each TweetID universally unique in our system and each TweetID should contain a timestamp too.
            We can use epoch time for this. Let’s say our TweetID will have two parts: the first part will be representing epoch seconds and 
            the second part will be an auto-incrementing sequence. So, to make a new TweetID, we can take the current epoch time and append an 
            auto-incrementing number to it. We can figure out the shard number from this TweetID and store it there.
            
Scenario 3: How to debug a remote server?
Solution 3: Using a debugger running on the host and connects to program on target to fetch information about the system -- GDB server
            GDB -- Execute this on host system to connect with target
            gdbserver -- run this on target server
            #gdbserver localhost:2000 my_program.py (target)
            #gd my_program.py (host)
            GDB is the GNU Project debugger, allows you to see what is going on `inside' another program while it executes
            
Scenario 4: How busy is the CPU?
Solution 4: #top (cpu load) #mpstat (cpu activity) #sar (cpu utilization) #iostat (average usage)

Scenario 5: What is loopback?
Solution 5: In linux every n/w connection can be added using nmcli -- every n/w connection there is a loopback -- loopbac is TCP/IP utility
            that allows interaction b/w Client and Server softwares -- troubleshooting using commands (ping, tracepath, traceroute)
            The loopback device is a special, virtual network interface that your computer uses to communicate with itself. 
            It is used mainly for diagnostics and troubleshooting, and to connect to servers running on the local machine.

Scenario 6: How to change priroty of a process?
Solution 6: renice or nice utiltity -- 
            Nice command will launch a process with an user defined scheduling priority. 
            Renice command will modify the scheduling priority of a running process. 
            Linux Kernel schedules the process and allocates CPU time accordingly for each of them.
                  
Scenario 7: How to view a url status without downloading its content?
Solution 7: You may use curl instead to check if the URLs you are parsing are there without downloading any file as such:

                        if curl --head --fail --silent "$url" >/dev/null; then
                            touch .images/"${url##*/}"
                        fi
                        Explanation:

                        --fail will make the exit status nonzero on a failed request.
                        --head will avoid downloading the file contents
                        --silent will avoid status or errors from being emitted by the check itself.
                        To solve the "looping" issue, you can do:

                        urls=( "${url%.jpg}"_{001..005}.jpg )
                        for url in "${urls[@]}"; do
                            if curl --head --silent --fail "$url" > /dev/null; then
                                touch .images/${url##*/}
                            fi
                        done
                        
                        urls=( "${url%.jpg}"_{001..005}.jpg )
                        for url in "${urls[@]}"; do
                            if wget -q --method=HEAD "$url"; then
                                touch .images/${url##*/}
                            fi
                        done
              What this does is that it invokes Wget with the --method=HEAD option. With the HEAD request, the server will simply report back whether the file exists or not, 
              without returning any data.
            
Scenario 8: What’s void *?
Solution 8: A pointer to void is a "generic" pointer type. A void * can be converted to any other pointer type without an explicit cast.void * is often used in places where you need to be able to work with different pointer types in the same code.
            
Scenario 9: What’s the system call for creating files?
Solution 9: The 0 file descriptor identifies the standard input, 1 identifies the standard output and 2 the standard output for errors. 
            The rest of the descriptors are used by the processes when opening an ordinary, pipe or special file, or directories. 
            There are five system calls that generate file descriptors: create, open, fcntl, dup and pipe.
            Open: read, write, lseek and close, Link, Unlink, stat, lstat, fstat
            Src: https://profile.iiita.ac.in/bibhas.ghoshal/lab_files/System%20calls%20for%20files%20and%20directories%20in%20Linux.html
            
Scenario 10: What happens when you hit curl in linux?
Solution 10: bash searches for executable "curl" in directories from PATH env var, once found it forks a process passing in the arg "www.google.com". 
            After that, a call to the kernel is made to handle requests to the network. The network stack is used (TCP/IP) to arbitrate for access to the resources, 
            the request gets broken down into muliple packets onto the network, first to DNS for address translation to IP, then out to the internet and back with muliple packets. 
            When arrived it gets checksumed and re-ordered and sent back to the application
            DETAILED: The shell splits a line of input into tokens.
             The shell performs wildcard expansion and parameter replacement on the tokens.
             If the first token, 'curl', is not an alias or shell function, then the shell will search the directories which are components of PATH for a matching file. 
             Each test in the sequence will be given to the kernel, which will resolve the directory path to a specific mounted filesystem, and then search the directory content in the filesystem.
            The shell will fork() creating a parent and child process.
            The kernel will handle the fork request by copying the process structure, stack, open files (including stdin, stdout, and stderr) 
                        and references to the heap memory to a new identical process, which will then be given a new process ID.
            The parent process will wait; the child process calls an exec() function.
            The kernel will determine if the path given to exec() is executable.
            For a dynamically linked ELF binary marked executable, the kernel will use ld.so to load the required shared objects into memory, 
                        resolve references to symbols in the shared objects into memory addresses, and begin execution of instructions in the ELF binary. 
                        The child shell process is replaced with the curl process.
            The curl process parses its command line arguments.
            The curl process will parse the argument it identifies as a URL in order to determine the protocol, host, port, and path.
            Curl will resolve the hostname to an address. I believe it will use getnameinfo(). The system resolver library will open /etc/nsswitch.conf to determine which modules to use for "hosts" resolution.
            The resolver library will dynamically load shared objects named in nsswitch.conf to continue dns resolution.
            The resolver library will parse /etc/resolv.conf in order to determine search domains, DNS servers, and other settings.
            The resolver library's "files" library will open /etc/hosts to check for the name.
            The resolver library's "dns" library will serialize the request for the host into requests for A and AAAA recordsThe .
            The resolver library will "open" a connection to the first DNS server and send the request.
            The kernel will create an IP packet containing its address and a newly allocated UDP port as the source, and the DNS servers's address and UDP port 53 as the destination.
            The kernel will check the routing table to see if the DNS server IP address is local, or if it requires routing through a gateway.
            The kernel will determine the MAC address of the next hop using either ARP for IPv4 or neighbor discovery for IPv6.
            The kernel will create an Ethernet frame containing the IP packet it created earlier, with its MAC address as the source and the MAC address of the next hop as the destination.
            The kernel sends the Ethernet frame.
(We have to REALLY simplify this for DNS or we'll go on forever.)
            If the DNS server doesn't have any answer cached, it'll send the request to the root name servers (A for www.example.com). The root nameservers will respond with the most specific information they have. If they don't know www.example.com or example.com, they may respond with the NS for "com". The DNS server then sends the request (A for www.example.com) to that nameserver. This process continues until it finds a nameserver that can answer the query. We will assume that the answer is small enough to fit in a UDP packet, and the process doesn't have to start over on TCP, but that can happen too.
            The client gets a reply, and now it knows the address for the host.
            curl will connect() to the IP address and TCP port. This follows a kernel process similar to the one we described earlier.
            The kernel of the client and server engage in a three-way handshake to establish a TCP connection. SYN, SYN/ACK, and ACK.
            We're going to skip TLS entirely, because wow that'd take a long time.
            curl serializes its request into the appropriate protocol That might be HTTP 1.1. The request might look like:
            GET /path HTTP/1.1
            Host: www.example.com
            The server parses the request, and decides how to handle it. Name-based virtual hosting may be a factor. The server may be a front-end for a web application, in which case the request is re-serialized and passed on through some other protocol over some other socket layer. If it resolves to a regular file, the server may be able to handle the request internally.
            The HTTP server builds a response that includes a description of the file it will send. It sends the description and then the file back over the client socket, and then closes the connection.
            curl reads the response headers in order to understand how it should handle the response.
            For an HTML file, curl will normally print to standard output. curl reads bytes from the network socket, and then writes those bytes to its standard output file.
            The kernel receives the bytes written to standard output and delivers them to the appropriate destination. This is probably to a TTY handled by a terminal emulator.
            You'll note that it starts to get vague at the end, because it's already a very long list and things are fairly complex. Depending on what your interests are, I may have left out the important stuff entirely. My conversation with my wife, for instance, was really directed at discussing TLS and how requests are handled by web frameworks. Both of those are excluded above.

Scenario 11: System calls, most importantly the popular ones like [src: https://linuxhint.com/list_of_linux_syscalls/]
            fork(): Creates child process [pid_t fork(void) --> Returns list of child processes]
            creat(): Create child process without copying page tables of parent process.  
            open(): Opens or creates a file, depending on the flags passed to the call. 
            read(): Reads from a specified file using a file descriptor. 
            write(): Writes to a specified file using a file descriptor.
            exec(): Execute a program.
            stat(): Returns information about a file in a structure named stat (lstat for symbolic link, fstat for file descriptor)
            sbrk(): change the location of the program break (brk())
            mmap(): Maps files or devices into memory.
            
Scenario 12: What does malloc() do and how to re-allocate or free memory? [src: https://man7.org/linux/man-pages/man3/malloc.3.html]
Solution 12: malloc():allocates size bytes and returns a pointer to the allocated memory.
             free(): frees the memory space pointed to by ptr, which must have been returned by a previous call to malloc()
             The Linux memory allocator works by mapping pages from physical memory to virtual memory. It can either map a contiguous area or sparse chunks from physical memory, 
             to a contiguous area in virtual memory. Using the buddy algorithm, physical memory can be arranged in contiguous sets of pages (let's call them buckets).
             
Scenario 13: File system internals, like the role of inode or dentry.
Solution 13: Superblock: file system metadata and defines the file system type, size, status, and information about other metadata structures (metadata of metadata). 
                        dumpe2fs /dev/foo | grep -i superblock
             Inode:represents metadata about a file.information about ownership (user, group), access mode (read, write, execute permissions), file type, and the data blocks with the file's content.
             Dentry: glue that holds inodes and files together by relating inode numbers to file names. Dentries also play a role in directory caching which, ideally, keeps the most frequently used files on-hand for faster access. 
                     File system traversal is another aspect of the dentry as it maintains a relationship between directories and their files.

Scenario 14: The lifecycle and the state of processes.
Solution 14: New--> Ready --> Running --> Waiting --> terminated --> Uninterruptible --> Zombie

Scenario 15: You are given disks with empty spaces, yet cannot write anything on the disks? What could be the reason?
Solution 15: Large file open OR lsof DELTED OR df -i

Scenario 20: You have a service Gerrit that is being restarted every 5 mins by systemd? troubleshoot (journalctl)
Solution 20: 1. Look for logs --> journalctl for logs (-u servicename, -t timestamp) / systemctl show logs (state of process) 2. Service setting could be set to restart via cronjob

Scenario 25: What is context switching:
Solution 25: Context Switching involves storing the context or state of a process so that it can be reloaded when required and execution can be resumed from the same point as earlier. 
            This is a feature of a multitasking operating system and allows a single CPU to be shared by multiple processes.
            Procedure: 1. Initially Process 1 is running. Process 1 is switched out and Process 2 is switched in because of an interrupt or a system call. 
                       2. Context switching involves saving the state of Process 1 into PCB1 and loading the state of process 2 from PCB2. 
                       3. After some time again a context switch occurs and Process 2 is switched out and Process 1 is switched in again. 
                       4. This involves saving the state of Process 2 into PCB2 and loading the state of process 1 from PCB1.
           
Scenario 26: Boot Process - Linux
Solution 26: 1. BIOS - Searches hard drives, USB, CD-ROMs, network cards, or any other hardware it can boot from.
                     - looks for actual firmware code at 000FFF0 (contains JMP instructions to actual BIOS code)
                     - Two Tasks:
                        - POST (Power On Selt Test): Identifies connected devices
                        - Boot: Calls INT 19h to start the boot process.
                                work loading its first sector to Master Boot Record (boot code(446 + partition)= 512 bytes
    
                     
             2. MBR: Master Boot Record, 512 bytes of HD this si where the boot code is.
             3. Boot Loader (GRUB 2)

Scenario : x86 Computers Operational Mode?
Solution : Real Mode: Access to first MB of memory only, 1st stage of boot process.
           Protected Mode: Multitasking, paging, protection rings.

Scenario 27: How to enrypt Passwords?
 Solution 27: 
 
 Scenario 28: Stateful set is for order of an application to start them in order
 Scenarios 29: Persistance app
Solution 29: PVPVC storage persistence Physical Volume (NFS storage) Physcial Volume Claim (Present to kubernetes volume for application)


Scenario 29: You are troubleshooting an app that is showing content not available. You can remotely access the application internet. Troubleshoot?
Solution 29: Traceroute application server - curl and see http response

Scenario 29.1: How traceroute works? How does it stop based on TTL? Where are the addresses given for the next hop?
Scenario 29.2: How curl works?
Scenario 29.2: What happends after tcp handshake/ at SSL/TLS level? How self signed certificate work?
Scenario 29.3: What does too many open files error mean? How does lsof work? Where is the limit mentioned? How do you see anything in /proc?
Scenario 20: Design a migration from On prem to Docker containers on Kubernetes cluster
Scenario : SSH not working so you login to console (ilo) mysql-admin:# prompt what does this mean? How do you troubleshoot if none of the commands working (FORK: resource not available)? inside proc how to get the info -- how to restart everything.
Scenario : Blackbox and whitebox monitoring? SLA,SLO,SLI
Scenario: Transfer huge number of files from one server to another?
Scenario: chroot
Solution: Extra security to run server in a chrooted enviroment (Jailed environment)- encapsulated filesystem that is prevented from interacting with your regular filesystem. 
            #named -t: specifies directory to chroot to
            #named -u: specifies uid under which run chrooted server
            “chroot jail cannot be empty since it must contain all the files the name server normally needs to run: /dev/null, /dev/random, the zone files, 
            configuration files, keys, syslog target files, UNIX domain socket for syslog, /var, etc. It takes a bit of work to set all this up. 
            The chroot system call is performed after libraries have been loaded, so you need not copy shared libraries into the jail.”
             The captive system shares your existing kernel.
            Used for : deprecated environemtn, recovery use chroot to mount the damaged filesystem to a mount point on a Live CD.
            Configure: Create libraries directories, ldd to list dependecies and install 
            reference: https://www.howtogeek.com/441534/how-to-use-the-chroot-command-on-linux/
            
Scenario: symlink vs hardlinnk
Solution: Hardlink: Points to the inode of the original file, hence changing/deleting the file will not change unless inode value is changed. Works in the same device.
          Softlink: Points to the name in the same location, hence any change to name or location will break the symbolic link. Works across device.
          Reference Counts: System open-file table entries, vnode table entries, and filesystem entries (inodes actually) each contain a counter (called a reference count) that tracks the number of references to that object. 
                            Each time one of the referencing objects goes away or changes to refer to something else, that counter gets dcecremented. When it hits zero, the object itself can be deleted. 
                            Reference counting is an important idea and is found in lots of places in CS.
                            
Scenario: inode vs file descriptors
Solution: inode: fil/dir attributes such as metadata and physical location on hardrive. The inode for a file contains the locations of each of the data blocks comprising the file
                 - DIRECTORY blocks: inode-filename pairs - entries like current or parent directory.
          file descriptors: the OS and the user process refer to each open connection by a number (type int) called a file descriptor. Standard input, output and error default to file descriptors 1, 2 and 3 respectively.
          
Scenario: How to send a signal to a process?
Solution: Send signal to a process using Kill -s USR1 pid
          Send signal using a C program with attributes = pid, SIGHUP
          Send signal from a keyboard (SIGINT CTR+ C that sends signal to kill foreground process (fg)) or (SIGQUIT CTRL + / or CTR + Y)
          View Key mappings with #stty -a | grep intr
  
Scenarios: How do you stop a fork bomb, when you are already in the system?
Solution: :(){ :|:& };:`. -- is FORK bomb
            :() - Define the function. The : is the function name and the opening and closing parenthesis means that the function does not accept any arguments
            { } - These characters show the beginning and end of the function
            :|: - Here it loads a copy of the function : into memory and pipe its own output to another copy of the : function, which has to be loaded into memory as well
            & - This starts the process as a background process
            : - The final : executes the function and hence the chain reaction begins
            
            If out of the system: Limit user access via PAM
            If inside the system: killall -STOP -u username
            
Scenario: Recover deleted log file?
Solution: /proc/pid/fd --> frep for Deleted and copy them in the logs file location

Scenario: * How look shared library dependencies?
Solution: ldd list dependeciens

Scenario: * How print the strings of printable characters in files?
Solution: using #strings

Scenario: What is nscd?
Solution: Nscd is a daemon that provides a cache for the most common name service requests. 
            The default configuration file, /etc/nscd. conf, determines the behavior of the cache daemon.

Scenario: What is automake?
Solution: So Automake was a new compiler that integrated with autoconf and processed "source" Makefile's (named Makefile.am) into Makefiles that could then be fed to Autoconf. 
            The automake/autoconf toolchain actually uses a number of other helper tools and they are augmented by other components for other specific tasks

Scenario: ELF?
Solution: n computing, the Executable and Linkable Format (ELF, formerly named Extensible Linking Format), is a common standard file format for executable files, object code, shared libraries, and core dumps. ... 
            By design, the ELF format is flexible, extensible, and cross-platform.
            #readelf or #objdump
            
Scenario: Major Minor numbers in file
Soltuion: The major device number is used to index the array when calling the code for a particular device driver. 
            The minor device number is passed to the device driver as an argument. 
            The minor number has no significance other than that attributed to it by the driver.
            
Scenario: &> and >/dev/null 2>&1 Two ways to redirect std error and std o/p to /dev/null
Solution: 2>&1 redirects standard error to standard output. &1 indicates file descriptor (standard output), 
            otherwise (if you use just 1 ) you will redirect standard error to a file named 1 . 
            [any command] >>/dev/null 2>&1 redirects all standard error to standard output, and writes all of that to /dev/null 
            
Scenario: chmod -x /bin/chmod
Solution: perl -e 'chmod(0755, "chmod")' systemcall

 
Git error: conflict , troubleshoot
Git commit needs to be reverted, how?
Jenkins logs how to check those? how to automatically fix build and error without manual intervention?
Website not responding, troubleshoot...strace
multiprocessing vs mltithreading
how to multiprocessing usingchunks which is variant
how to parse a json file
array and dictionary
synchronous and asynchronous
how to migrate to aws what all steps to consider and security to make sure for a private servers?
how to set an interfac's MTU. (ifconfig ip-link)


echo "- - -" > /sys/class/scsi_host/host0/scan
            The three values stand for channel, SCSI target ID, and LUN. The dashes act as wildcards meaning "rescan everything"
/nfsroot 192.168.5.0/24(ro,no_root_squash,no_subtree_check) 

Scenario: read vs fread: 
Solution: the fread() function is used to read data from a file and store it in a buffer

Scenario: Process Address Space
Solution: The process address space is the set of logical addresses that a process references in its code. For example, when 32-bit addressing is in use, addresses can range from 0 to 0x7fffffff; that is, 2^31 possible numbers, for a total theoretical size of 2 gigabytes.

Scenario: Race Condition:
Soltuion: A race condition is an undesirable situation that occurs when a device or system attempts to perform two or more operations at the same time, but because of the nature of the device or system, the operations must be done in the proper sequence to be done correctly.

Scenario: Deadlock
Solution: Deadlock is a situation that occurs in OS when any process enters a waiting state because another waiting process is holding the demanded resource. Deadlock is a common problem in multi-processing where several processes share a specific type of mutually exclusive resource known as a soft lock or software.

Scenario: Big-endian and Little-endian (storing multibyte data-types)
Solution: Big-endian is an order in which the "big end" (most significant value in the sequence) is stored first (at the lowest storage address). Little-endian is an order in which the "little end" (least significant value in the sequence) is stored first.

Scenario: Mutex vs Semaphores
Solution: mutexes and semaphores are kernel resources that provide synchronization services
          Mutex: (locking) provides mutual exclusion, either producer or consumer can have the key (mutex) and proceed with their work. As long as the buffer is filled by the producer, the consumer needs to wait, and vice versa. 
          Sempahore: (signalling) A semaphore is a generalized mutex. In lieu of a single buffer, we can split the 4 KB buffer into four 1 KB buffers (identical resources). A semaphore can be associated with these four buffers. The consumer and producer can work on different buffers at the same time.

Scenario: Debug process
Soltuion:   Set a breakpoint and start the debugger.
            Navigate code in the debugger using step commands.
            Step over code to skip functions.
            Step into a property.
            Run to a point in your code quickly using the mouse.
            Advance the debugger out of the current function.
            Run to cursor.
            Restart your app quickly.
            
Scenario: Troubleshoot system unresponsive, ssh is not working.
            

4. What is the route for network traffic when one tries to connect to any site like fb
  
 5. What is average load in linux
 6. Use of inodes and file descriptors
 7. Use of swap space in linux
 Q 4. How to debug a website that is slowing down
  -- 
  Q 5. What kind of hypervisors you know ?

